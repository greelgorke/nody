    <section class="suite">
      <h1>cond</h1>
      <dl>
        <section class="suite">
          <h1>pipe</h1>
          <dl>
            <dt>should accept matcher in pipe</dt>
            <dd><pre><code>var _cond = cond()
var testPipe = new stream.PassThrough({objectMode: true})
_cond.pipe(positiveMatcher, testPipe)

assert( _cond._matchers[0] === positiveMatcher )
assert( _cond._matchingStreams[0] === testPipe )

done()</code></pre></dd>
            <dt>should return accepted matching stream in pipe</dt>
            <dd><pre><code>var _cond = cond()
var testPipe = new stream.PassThrough({objectMode: true})
var pipedStream = _cond.pipe( positiveMatcher, testPipe )

assert( testPipe === pipedStream )
done()</code></pre></dd>
            <dt>should return stream without matcher in pipe</dt>
            <dd><pre><code>var _cond = cond()
var testPipe = new stream.PassThrough({objectMode: true})
var pipedStream = _cond.pipe( testPipe )

assert( testPipe === pipedStream )
done()</code></pre></dd>
            <dt>should proxy the core pipe</dt>
            <dd><pre><code>var _cond = cond()


testPipe.on('pipe', function(s){
  assert.strictEqual( _cond, s )
  done()
})
_cond.pipe(testPipe)

assert( _cond._matchers[0] == null )
assert( _cond._matchingStreams[0] == null )</code></pre></dd>
            <dt>should proxy the core pipe</dt>
            <dd><pre><code>var _cond = cond()

assert.throws(function(){
  _cond.pipe(positiveMatcher)
}, Error)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>matcher</h1>
          <dl>
            <dt>should pass the params and a callback to the matcher function</dt>
            <dd><pre><code>var _cond = cond()
var p1 = &quot;foo&quot;
var p2 = {bar : true}
function assertingMatcher(param1, param2, callback){
  assert.strictEqual( p1, param1 )
  assert.strictEqual( p2, param2 )
  assert            ( typeof callback == 'function' )
  done()
}

_cond.pipe(assertingMatcher, testPipe)
_cond.write(piped(p1, p2))
_cond.end()</code></pre></dd>
            <dt>should write to the positive matching stream, not the negative</dt>
            <dd><pre><code>var _cond = cond()
var p1 = &quot;foo&quot;
var positiveStream = new stream.Writable({objectMode: true})
positiveStream._write = function(item, enc, cb ){
  assert.equal( p1, item.payload[0])
  done()
}
var negativeStream = new stream.Writable({objectMode: true})
negativeStream._write = function(item, enc, cb ){
  assert.fail()
}

_cond.pipe(negativeMatcher, negativeStream)
_cond.pipe(positiveMatcher, positiveStream)
_cond.write(piped(p1))
_cond.end()</code></pre></dd>
            <dt>should write to the first positive matching stream, not the second</dt>
            <dd><pre><code>var _cond = cond()
var p1 = &quot;foo&quot;

var positiveStream1 = new stream.Writable({objectMode: true})
positiveStream1._write = function(item, enc, cb ){
  assert.equal( p1, item.payload[0])
}

var positiveStream2 = new stream.Writable({objectMode: true})
positiveStream2._write = function(item, enc, cb ){
  assert.fail()
}

_cond.on('finish', function(){done()})
_cond.pipe(positiveMatcher, positiveStream1)
_cond.pipe(positiveMatcher, positiveStream2)
_cond.write(piped(p1))
_cond.end()</code></pre></dd>
            <dt>should write to the catch-all stream, if nothing matches the second</dt>
            <dd><pre><code>var _cond = cond()
var p1 = &quot;foo&quot;
var catchAllStream = new stream.Writable({objectMode: true})
catchAllStream._write = function(item, enc, cb ){
  assert.equal( p1, item.payload[0])
  done()
}
var negativeStream = new stream.Writable({objectMode: true})
negativeStream._write = function(item, enc, cb ){
  assert.fail()
}

_cond.pipe(negativeStream, negativeStream)
_cond.pipe(catchAllStream)
_cond.write(piped(p1))
_cond.end()</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>cons</h1>
      <dl>
        <dt>should pass the context in simple write</dt>
        <dd><pre><code>var contextProvided = 'the context'
var consumer = cons()

consumer.on('readable', function(){
  var result = consumer.read()
  assert.equal( contextProvided, result.payload[0] )
  done()
})
consumer.write(contextProvided)
consumer.end()</code></pre></dd>
        <dt>should pass the sontext with pack/submit</dt>
        <dd><pre><code>var contextProvided = 'the context'
var consumer = cons()

consumer.on('readable', function(){
  var result = consumer.read()
  assert.equal( contextProvided, result.payload[0] )
  assert.equal( contextProvided, result.payload[1] )
  assert.equal( contextProvided, result.payload[2] )
  done()
})

consumer.pack(contextProvided,contextProvided)
consumer.pack(contextProvided)
consumer.submit()
consumer.end()</code></pre></dd>
        <dt>should not submit if nothing there to submit</dt>
        <dd><pre><code>var contextProvided = 'the context'
var consumer = cons()

consumer.on('readable', function(){
  assert.fail()
})

consumer.on('finish', done)

consumer.submit()
consumer.end()</code></pre></dd>
        <dt>should not mix writes and packs</dt>
        <dd><pre><code>var contextProvided = 'the context'
var contextWritten = 'written!'
var consumer = cons()

consumer.on('finish', done)

consumer.on('readable', function(){
  var result = consumer.read()
  assert.equal( contextWritten, result.payload[0] )
  assert( ! Array.isArray( result ))
})

consumer.pack(contextProvided,contextProvided)
consumer.write(contextWritten)
consumer.end()</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>merge</h1>
      <dl>
        <section class="suite">
          <h1>pipe/unpipe</h1>
          <dl>
            <dt>should keep track of piped streams</dt>
            <dd><pre><code>var _merge = merge.takeLastMerge()
var pt1 = new stream.PassThrough({objectMode:true})
var pt2 = new stream.PassThrough({objectMode:true})
pt1.pipe(_merge)
pt2.pipe(_merge)

assert.equal( 2, _merge.mergeCount )

pt1.unpipe(_merge)

assert.equal( 1, _merge.mergeCount )</code></pre></dd>
            <dt>should not keep track of piped streams</dt>
            <dd><pre><code>var _merge = merge( merge.strategies.firstWins, 1 )
var pt1 = new stream.PassThrough({objectMode:true})
var pt2 = new stream.PassThrough({objectMode:true})
pt1.pipe(_merge)
pt2.pipe(_merge)

assert.equal( 1, _merge.mergeCount )

pt1.unpipe(_merge)

assert.equal( 1, _merge.mergeCount )</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>merger</h1>
          <dl>
            <section class="suite">
              <h1>check</h1>
              <dl>
                <dt>should not call the merger function if merger check refuses</dt>
                <dd><pre><code>var pl1 = 'foo', pl2 = 'bar'
var item = piped( pl1, pl2 )

var pt = new stream.PassThrough({objectMode:true})

function assertingMerger(arr1, arr2, callback){
  assert.fail()
}

var _merge = merge(assertingMerger, function(){ return false })

_merge.on('readable', function(){
  assert.fail()
})

_merge.on('finish', function(){done()})
pt.pipe( _merge )
pt.write(item)
pt.end()</code></pre></dd>
                <dt>should call the merger function if merger check accepts</dt>
                <dd><pre><code>var pl1 = 'foo', pl2 = 'bar'
var item = piped( pl1, pl2 )

var pt = new stream.PassThrough({objectMode:true})

function assertingMerger(arr1, arr2, callback){
  assert( Array.isArray( arr1 ) )
  assert( typeof callback === 'function' )
  done()
}
var mergeCheck = function(){ return true }
var _merge = merge( assertingMerger, mergeCheck )

_merge.on('readable', function(){
  var res = _merge.read()
  assert.deepEqual( item.payload, res.payload )
  done()
})

pt.pipe( _merge )
pt.write(item)
pt.end()</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>merge</h1>
              <dl>
                <dt>should pass one argument array to the mergerFunction</dt>
                <dd><pre><code>var pl1 = 'foo', pl2 = 'bar'
var item = piped( pl1, pl2 )

var pt1 = new stream.PassThrough({objectMode:true})

function assertingMerger(arr1, arr2, callback){
  assert( Array.isArray( arr1 ) )
  assert( arr2 == null )
  assert( typeof callback === 'function' )
  done()
}

var _merge = merge(assertingMerger, function(){return true})

pt1.pipe(_merge)

pt1.write(item)</code></pre></dd>
                <dt>should pass two argument arrays to the mergerFunction</dt>
                <dd><pre><code>var pl1 = 'foo', pl2 = 'bar'
var item = piped( pl1, pl2 )

var pt1 = new stream.PassThrough({objectMode:true})

function assertingMerger(arr1, arr2, callback){
  assert( Array.isArray( arr1 ) )
  assert( Array.isArray( arr2 ) )
  assert( typeof callback === 'function' )
  done()
}

var _merge = merge( assertingMerger, 2 )

pt1.pipe(_merge)

pt1.write(item)
pt1.write(item)</code></pre></dd>
                <dt>should pass apply mergerFunction result</dt>
                <dd><pre><code>var pl1 = 'foo', pl2 = 'bar'
var item1 = piped( pl1, pl2 )

var pt1 = new stream.PassThrough({objectMode:true})

function merger(arr1, arr2, callback){
  callback( null, [ arr1[0] + arr2[0], arr1[1] + arr2[1] ] )
}

var _merge = merge( merger, 3 )

_merge.on('readable', function(){
  var res = _merge.read()
  assert.equal( pl1+pl1+pl1 , res.payload[0] )
  assert.equal( pl2+pl2+pl2 , res.payload[1] )
  done()
})
pt1.pipe(_merge)

pt1.write(item1)
pt1.write(item1)
pt1.write(item1)</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>threshhold</h1>
          <dl>
            <dt>should emit threshhold event</dt>
            <dd><pre><code>var _merge = merge(merge.strategies.lastWins, 4)
var foo = piped('foo')
var bar = piped('bar')


_merge.onThreshhold( 1, function(cache){
  assert( Array.isArray(cache) )
  assert.equal( 2, cache.length )
  done()
})
_merge.write( foo )
_merge.write( bar )</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>node</h1>
      <dl>
        <dt>should throw an error on construction, when no processor being provided</dt>
        <dd><pre><code>assert.throws(function(){
  node()
}, Error)</code></pre></dd>
        <dt>should call the provided processor</dt>
        <dd><pre><code>var ctx = 'lalalala'
var _node = node( function(item, callback){
  assert.equal( ctx, item )
  assert( typeof callback == 'function')
  done()
})

_node.write( piped(ctx) )
_node.end()</code></pre></dd>
        <dt>should call the provided processor and replace the item</dt>
        <dd><pre><code>var ctx = 'lalalala'
var _node = node( function(item, callback){
  callback(null, item+item)
})

_node.on('readable', function(){
  assert.equal( ctx+ctx, _node.read().payload[0])
  done()
})

_node.write( piped(ctx) )
_node.end()</code></pre></dd>
        <dt>should call the provided processor and emit error</dt>
        <dd><pre><code>var ctx = 'lalalala'
var _node = node( function(item, callback){
  callback(new Error('foo'))
})

_node.on('error', function(){
  done()
})

_node.write( piped(ctx) )
_node.end()</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>piped</h1>
      <dl>
        <dt>should generate a piped object</dt>
        <dd><pre><code>var testArgs = ['a','b']
var testPiped = piped.apply(null, testArgs)
assert.deepEqual( testArgs, testPiped.payload )</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>piping</h1>
      <dl>
        <dt>should augment a stream with custom .pipe</dt>
        <dd><pre><code>var testSource = new stream.PassThrough()
piping( testSource )
assert.strictEqual    ( typeof testSource.pipe, 'function' )
assert.notStrictEqual ( Object.getPrototypeOf( testSource ).pipe , new stream.Stream().pipe )</code></pre></dd>
        <dt>should throw a TypeError if candidate doesn't have pipe method</dt>
        <dd><pre><code>assert.throws( function(){
  piping({})
} , TypeError)</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>new pipe</h1>
      <dl>
        <dt>should throw an Error if candidate stream isn't in object mode</dt>
        <dd><pre><code>var testSource = new stream.PassThrough()
piping( testSource )
var testTarget = new stream.PassThrough()

assert.throws( function(){
  testSource.pipe( testTarget )
} , Error)</code></pre></dd>
        <dt>should not throw if candidate stream is in object mode</dt>
        <dd><pre><code>var testSource = new stream.PassThrough()
piping( testSource )
var testTarget = new stream.PassThrough({objectMode: true})

testSource.pipe( testTarget )</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>sink</h1>
      <dl>
        <dt>should pass the context in simple case</dt>
        <dd><pre><code>var contextProvided = 'the context'
var _sink = sink( fallThroughHandler )

function fallThroughHandler( context ){
  assert.equal( contextProvided, context )
  done()
}

_sink.write( piped( contextProvided ) )
_sink.end()</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>utils</h1>
      <dl>
        <section class="suite">
          <h1>asyncReduce</h1>
          <dl>
            <dt>should reduce right</dt>
            <dd><pre><code>var testArr = [1,2,3,4,5,6]
var expected = 1+2+3+4+5+6

function reducer( sum, elem, next ){
  next(null, sum+elem)
}

function callback(err, result){
  assert.equal( expected, result )
  assert( testArr.length == 6 )
  done(err)
}

utils.asyncReduce( testArr, reducer, callback)</code></pre></dd>
            <dt>should reduce pass the error</dt>
            <dd><pre><code>var testArr = [1,2,3,4,5,6]
var expected = 1+2+3+4+5+6

function reducer( sum, elem, next ){
  next(new Error())
}

function callback(err, result){
  assert( util.isError(err) )
  done()
}

utils.asyncReduce( testArr, reducer, callback)</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>wrap</h1>
      <dl>
        <section class="suite">
          <h1>constructor</h1>
          <dl>
            <dt>should fail with no consumer stream</dt>
            <dd><pre><code>assert.throws( function(){
  wrap()
}, TypeError)</code></pre></dd>
            <dt>should not fail with a consumer stream</dt>
            <dd><pre><code>assert.doesNotThrow( function(){
  wrap(new stream.PassThrough({objectMode:true}))
})</code></pre></dd>
            <dt>should save the producer streams</dt>
            <dd><pre><code>var _wrap = wrap( new stream.PassThrough({objectMode:true})
                  , new stream.PassThrough({objectMode:true})
                  , new stream.PassThrough({objectMode:true})
                  )

assert( Array.isArray(_wrap.producers))
assert( _wrap.producers.lenght = 2)</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>consuming</h1>
          <dl>
            <dt>should write to the consumer</dt>
            <dd><pre><code>var consumer = new stream.PassThrough({objectMode:true})
var item = &quot;foo&quot;
var _wrap = wrap( consumer )

consumer.on('readable', function(){
  var res = consumer.read()

  assert.equal( item, res )
  done()
})

_wrap.write(item)</code></pre></dd>
            <dt>should read from a producer</dt>
            <dd><pre><code>var consumer = new stream.PassThrough({objectMode:true})
var producer = new stream.PassThrough({objectMode:true})
var item = &quot;foo&quot;
var _wrap = wrap( consumer, producer )

_wrap.on('readable', function(){
  var res = _wrap.read()

  assert.equal( item, res )
  done()
})

producer.write(item)</code></pre></dd>
            <dt>should read from different producers</dt>
            <dd><pre><code>var consumer = new stream.PassThrough({objectMode:true})
var producer1 = new stream.PassThrough({objectMode:true})
var producer2 = new stream.PassThrough({objectMode:true})
var item1 = &quot;foo&quot;
var item2 = &quot;foo2&quot;
var _wrap = wrap( consumer, producer1, producer2 )

_wrap.once('readable', function(){
  var res = _wrap.read()

  assert.equal( item1, res )

  _wrap.once('readable', function(){
    var res = _wrap.read()

    assert.equal( item2, res )
    done()
  })
})

producer1.write(item1)
producer2.write(item2)</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
